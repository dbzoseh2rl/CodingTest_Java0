/* 있다가 다시 */
import java.io.*;
import java.util.*;

public class BOJ_1491 {
    public static void main(String[] args) throws IOException {
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
//        StringTokenizer st = new StringTokenizer(br.readLine());
//
//        int N = Integer.parseInt(st.nextToken());
//        int M = Integer.parseInt(st.nextToken());
//        int[][] arr = new int[M][N];
////        System.out.println(Arrays.deepToString(arr));
//
//        // 방향 벡터 (동, 남, 서, 북)
//        int[][] direction = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
//        int dir = 0; // 처음에 동쪽을 향함
//        int x = 0, y = 0;
//
//        for (int i = 0; i < N * M; i++) {
//            arr[x][y] = 1; // 방문 기록
//
//            int nx = x + direction[dir][0];
//            int ny = y + direction[dir][1];
////            nx < 0 || nx >= N || ny < 0 || ny >= M
////            ny>= M|| arr[nx][ny] == 1
//            // 다음 위치가 벽을 만나거나 이미 방문한 곳이면 방향 전환
//            if (ny >= N ) {
//                dir = (dir + 1) % 4; // 방향을 오른쪽으로 회전 (시계 방향)
//                nx = x + direction[dir][0];
//                ny = y + direction[dir][1];
//            }
//            if (nx >= M) {
//                dir = (dir + 1) % 4;
//                nx = x + direction[dir][0];
//                ny = y + direction[dir][1];
//            }
//
//            System.out.println(x + " " + y);
//
//
//
//        ;
//        // 배열의 중심을 기준으로 (N/2 - 1, M/2) 위치가 답이 되도록 설정
////        System.out.println((N / 2 - 1) + " " + (M / 2));


    }
}
